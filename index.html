<!doctype html>
<html>
  <head>
      <script src="https://cdn.jsdelivr.net/pyodide/v0.28.3/full/pyodide.js"></script>
	  <style>
		html {
		  height: 100%;
		}
		body {
		  padding: 0;
		  margin: 0;
		  display: flex;
		  flex-direction: column;
		  height: 100%;
		}

		.nav {
		  width: 100%;
		  min-height: 50px;
		  background: navy;
		  font-family: Arial, Sans-serif;
		  color: white;
		  text-align: right;
		  padding: 10px 20px;
		  box-sizing: border-box;
		}
		.nav h1 {
		  margin: 0;
		}

		.main {
		  display: flex;
		  flex-grow:1;
		}
		.main div {
		  flex-basis: 50%;
		}
		.left {
		  background-color: lightgrey;
		  
		  justify-content: center;
		}
		.right {
		  background-color: coral;
		}

		.ðŸ’ªcenter {
		  display: flex;
		  align-items: center;
		  justify-content: center;
		  flex-direction: column;
		}
		#codeWindow {
		  font-family: monospace;
		  resize: none;
		  outline: none;
		}
		#loader {
			font-weight: bold;
			flex-grow: 0;
			flex-basis: 0;
			}
		#instructions {
			flex-basis: 0;
			flex-grow: 0;
			margin-bottom: 20px;
		}
	  </style>

  </head>
  <body>
	<div class="nav">
	  <h1>POCC</h1>
	</div>
	<div class="main">
	  <div class="left ðŸ’ªcenter">
		<div id="loader">Loading Python runtime... Please wait.</div>
		<button id="testsButton" disabled>Run Tests</button>
		<pre id="resultsWindow"></pre>
	  </div>
	  <div class="right ðŸ’ªcenter">
		<div id="instructions">
			<ul>
				<li>Create a variable called greeting with the value Hello</li>
				<li>Create a function called greet which takes in a name and says "Hello, [name]!" with the name given</li>
				<li>Create a function called add which takes two numbers and returns the sum</li>
			</ul>
		</div>
		<textarea name="code-window" id="codeWindow" cols="80" rows="20" placeholder="Enter your code here" wrap="off"></textarea>
	  </div>

	</div>
  </body>
  <script>
	const codeInput = document.getElementById('codeWindow');
	const runButton = document.getElementById('testsButton');
	const resultsOutput = document.getElementById('resultsWindow');
	const loader = document.getElementById('loader');


	//js to display results as a table
	function createTable(jsonString, container) {
		let data;
		try {
			data = JSON.parse(jsonString);
		} catch (error) {
			container.innerHTML = "<p>Something went wrong parsing JSON string</p>";
			return;
		}
		// Check the data is an array and not empty
		if (!Array.isArray(data) || data.length === 0) {
			container.innerHTML = "<p>No data to display.</p>";
			return;
		}
		//create table elements
		const table = document.createElement('table');
		const thead = document.createElement('thead);
		const headerRow = document.createElement('tr');
		//add table headers
		const headers = Object.Keys(data[1]); //assume 0th index is summary data
		headers.forEach(hText => {
			const th = document.createElement('th');
			th.textContent = hText;
			headerRow.appendChild(th);
		});
		thead.appendChild(headerRow);
		table.appendChild(thead);

		//fill table with data
		const tbody = document.createElement('tbody');
		data.slice(1).forEach(obj => {
			const row = document.createElement('tr');
			headers.forEach(header => {
				const cell = document.createelement('td');
				cell.textContent = obj[header] !== null ? obj[header] : "";
				row.appendChild(cell);
			});
			tbody.appendChild(row);
		});
		table.appendChild(tbody);

		//reset container and display
		container.innerHTML = "";
		container.appendChild(table);
	}
	// The new, more comprehensive testCode string
	const testCode = `
	import io
	import inspect
	from contextlib import redirect_stdout
	import json
	
	PASSED = 1
	FAILED = -1
	SKIPPED = 0
	
	class Tester:
	    def __init__(self):
	        self.results = []
	        self.count_tests = 0
	        self.count_pass = 0
	        self.count_fail = 0
	        
	    def include_result(self, description, success):
	        #success 1 = pass, 0 = skipped, -1 = failed
	        result = {}
	        self.count_tests += 1
	        result["testNumber"] = self.count_tests
	        result["testDescription"] = description
	        if success == PASSED:
	            self.count_pass += 1
	            result["testResult"] = "PASSED"
	            result["resultIcon"] = "ðŸŸ¢"
	        elif success == FAILED:
	            self.count_fail += 1
	            result["testResult"] = "FAILED"
	            result["resultIcon"] = "ðŸ”´"            
	        else:
	            result["testResult"] = "SKIPPED"
	            result["resultIcon"] = "ðŸŸ¡"
	        self.results.append(result)
	        
	    def confirm_variable_exists(self, v_name):
	        return v_name in globals()
	    def check_variable_exists(self, v_name):
	        result = PASSED if self.confirm_variable_exists(v_name) else FAILED
	        description = f"Check variable with name {v_name} exists."
	        self.include_result(description ,result)
	    
	    def check_variable_value(self,v_name,expected_value):
	        if self.confirm_variable_exists(v_name):
	            description = f"Check variable {v_name} has value {expected_value}."
	            actual_value = globals()[v_name]
	            result = PASSED if actual_value == expected_value else FAILED
	            self.include_result(description, result)
	        else:
	            self.include_result(f"Unable to find variable {v_name} to check value", SKIPPED)
	    
	    def confirm_function_exists(self,f_name):
	        return f_name in globals() and callable(globals().get(f_name))
	    def check_function_exists(self,f_name):
	        result = PASSED if self.confirm_function_exists(f_name) else FAILED
	        description = f"Check function with name {f_name} exists."
	        self.include_result(description, result)
	    
	    def confirm_function_parameters(self,f_name, expected_count):
	        if self.confirm_function_exists(f_name):
	            signature = inspect.signature(globals()[f_name])
	            actual_count = len(signature.parameters)
	            return actual_count == expected_count
	        return False
	    def check_function_parameters(self,f_name,expected_count):
	        if self.confirm_function_exists(f_name):
	            description = f"Check function {f_name} has {expected_count} parameter(s)."
	            signature = inspect.signature(globals()[f_name])
	            actual_count = len(signature.parameters)
	            result = PASSED if actual_count == expected_count else FAILED
	            self.include_result(description,result)
	        else:
	            self.include_result(f"Unable to find function {f_name} to check parameters",SKIPPED)
	    
	    def check_function_print(self,f_name,args,expected_print, hide_expected = False):
	        if self.confirm_function_exists(f_name) and self.confirm_function_parameters(f_name,len(args)):
	            description = f"Check function outputs. Testing with argument(s): "
	            for a in args:
	                description += f"{a}, "
	            description = description[:-2] + ". "
	            if not hide_expected:
	                description += f"Expected output: '{expected_print}'."
	            func = globals()[f_name]
	            fake = io.StringIO()
	            with redirect_stdout(fake):
	                func(*args)
	            actual_print = fake.getvalue().strip()
	            result = PASSED if actual_print == expected_print else FAILED
	            if result == FAILED and not hide_expected:
	                description += f" Actual output: '{actual_print}'."
	            self.include_result(description,result)
	        else:
	            self.include_result(f"Unable to check print of function {f_name}, cannot find or parameters don't match.",SKIPPED)
	    def check_function_return(self, f_name, args, expected_return, hide_expected = False):
	        if self.confirm_function_exists(f_name) and self.confirm_function_parameters(f_name, len(args)):
	            description = f"Check function return. Testing with argument(s): "
	            for a in args:
	                description += f"{a}, "
	            description = description[:-2] + ". "
	            if not hide_expected:
	                description += f"Expected output: {expected_return}."
	            func = globals()[f_name]
	            actual_return = func(*args)
	            result = PASSED if actual_return == expected_return else FAILED
	            if result == FAILED and not hide_expected:
	                description += f" Actual return: {actual_return}."
	            self.include_result(description,result)
	        else:
	            self.include_result(f"Unable to check print of function {f_name}, cannot find or parameters don't match.",SKIPPED)
	    def json_results(self):
	        summary = {
	            "testCount" : self.count_tests,
	            "passCount" : self.count_pass,
	            "failCount" : self.count_fail,
	            "skipCount" : self.count_tests - self.count_pass - self.count_fail,
	            }
	        return json.dumps([summary] + self.results)
	
	tester = Tester()
	try:
	    #example test code
	    tester.check_variable_exists("greeting")
	    tester.check_variable_value("greeting", "Hello")
	    tester.check_variable_value("missing", "oops")
	    tester.check_function_exists("greet")
	    tester.check_function_parameters("greet", 1)
	    tester.check_function_print("greet",args = ["Bob",],expected_print = "Hello, Bob!")
	    tester.check_function_return("greet", ["Bob",], 1)
	except Exception as e:
	    tester.results.append({
	        "testNumber" : -1,
	        "testDescription" : f"Critical error - test code could not complete: {e}",
	        "testResult" : FAILED,
	        "resultIcon" : "ðŸ”´" })
	
	#final expression returned to JavaScript
	tester.json_results()
	`;

	async function setupPyodide() {
		let pyodide = await loadPyodide();
		loader.textContent = 'Python runtime loaded! Ready to run code.';
		runButton.disabled = false;
		return pyodide;
	}

	const pyodidePromise = setupPyodide();

	runButton.addEventListener('click', async () => {
		const pyodide = await pyodidePromise;
		const userCode = codeInput.value;
		resultsOutput.textContent = 'Running tests...';
		
		
		let output = '';
		
		try {
			// Run the user's code to make their function available
			pyodide.runPython(userCode);
			
			// Assign the captured string to the 'output' variable
			output = pyodide.runPython(testCode);
			createTable(output, resultsWindow);
		} catch (error) {
			// This will catch syntax errors in the user's code
			output = "Code would not run - please test in an IDE";
			resultsOutput.textContent = output;
		}
	});
</script>
</html>
