<!doctype html>
<html>
  <head>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.28.3/full/pyodide.js"></script>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&family=Source+Code+Pro&display=swap" rel="stylesheet">
<style>
    /* --- 1. Modern Theme & Color Palette --- */
    :root {
        --dark-blue: #2c3e50;
        --medium-blue: #34495e;
        --light-grey: #ecf0f1;
        --accent-green: #27ae60;
        --accent-green-hover: #2ecc71;
        --text-light: #ffffff;
        --text-dark: #333333;
        --border-color: #bdc3c7;
    }
    *, *:before, *:after {
        box-sizing: inherit;
    }
    html {
        height: 100%;
        font-size: 1.2rem;
        font-family: 'Poppins', sans-serif;
		box-sizing: border-box;
    }

    body {
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        height: 100%;
        background-color: var(--light-grey);
        color: var(--text-dark);
    }

    .nav {
        background: var(--dark-blue);
        color: var(--text-light);
        padding: 15px 30px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        z-index: 10;
    }
    .nav h1 {
        margin: 0;
        font-weight: 600;
        text-align: left;
    }

    .main {
        display: flex;
        flex-grow: 1;
        gap: 20px;
        padding: 20px;
        overflow: hidden; 
    }


    .main > div {
        flex: 1 1 50%;
        background-color: var(--text-light);
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        min-height: 0;
        overflow: hidden;
        display: flex; 
    }
    .content-wrapper {
        width: 100%;
        height: 100%;
        overflow-y: auto;
        padding: 25px;
        scroll-behavior: smooth;
    }
	
    @media (prefers-reduced-motion: reduce) {
        .content-wrapper {
            scroll-behavior: auto;
        }
    }

    @media (orientation: portrait), (max-width: 800px) {
        .main {
            flex-direction: column;
            overflow: auto;
        }
        
        .main > div {
            flex-basis: auto;
            overflow: visible; 
            flex-shrink: 0;
        }
        
        .content-wrapper {
            overflow-y: visible; 
            padding: 25px;
        }
    }

    .left .content-wrapper.ðŸ’ªcenter {
        justify-content: flex-start;
    }
	.right .content-wrapper.ðŸ’ªcenter {
        height: auto;
    }

    .ðŸ’ªcenter {
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
    }

    .left.ðŸ’ªcenter {
        justify-content: flex-start;
    }

    #instructions {
        width: 100%;
        margin-bottom: 20px;
        text-align: left;
        border-left: 4px solid var(--medium-blue);
        padding-left: 15px;
        background-color: #f8f9fa;
        border-radius: 4px;
    }
    #instructions ul {
        padding-left: 20px;
    }

    #codeWindow {
        font-family: 'Source Code Pro', monospace;
        resize: none;
        outline: none;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 15px;
        width: 100%;
        box-sizing: border-box;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        transition: border-color 0.3s, box-shadow 0.3s;
        flex-grow: 1; 
    }
    #codeWindow:focus {
        border-color: var(--dark-blue);
        box-shadow: 0 0 5px rgba(44, 62, 80, 0.3);
    }

    #testsButton {
        background-color: var(--accent-green);
        color: var(--text-light);
        border: none;
        border-radius: 5px;
        padding: 12px 25px;
        font-size: 1.1rem;
        font-weight: 600;
        cursor: pointer;
        transition: background-color 0.3s, transform 0.2s;
        margin: 15px 0;
        flex-shrink: 0; 
    }
    #testsButton:disabled {
        background-color: #95a5a6;
        cursor: not-allowed;
    }
    #testsButton:not(:disabled):hover {
        background-color: var(--accent-green-hover);
        transform: translateY(-2px);
    }

    #resultsWindow {
        width: 100%;
    }
    #resultsWindow table {
        margin-top: 10px;
        border: 1px solid var(--border-color);
        width: 100%;
        text-align: left;
        border-collapse: collapse;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }
    #resultsWindow table td, #resultsWindow table th {
        border-top: 1px solid var(--border-color);
        padding: 10px 12px;
    }
    #resultsWindow table thead {
        background-color: var(--medium-blue);
        color: var(--text-light);
    }
    #resultsWindow table thead th {
        text-align: left;
        font-weight: 600;
    }
    .resultRow {
        opacity: 0;
        animation: fadeInUp 0.5s ease-out forwards;
    }
    @keyframes fadeInUp {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
</style>

  </head>
  <body>
	<div class="nav">
	  <h1>POCC - <em>Variables - Warm Up</em></h1>

	</div>
	<div class="main">
		<div class="left">
			<div class="content-wrapper ðŸ’ªcenter"> 
				<div id="loader">Loading Python runtime... Please wait.</div>
				<button id="testsButton" disabled>Run Tests</button>
				<div id="resultsWindow"></div>
			</div>
		</div>
		<div class="right">
			<div class="content-wrapper ðŸ’ªcenter">
				<div id="instructions">
					<p>For this excercise you will create some variables and assign them a value. You will need to make sure you add the correct data type for each variable.</p>
					<ul>
						<li>Create a variable called username, set it to Ada Lovelace</li>
						<li>Create a variable called title, set it to World's first Computer Programmer</li>
						<li>Create a variable called age, set it to 17</li>
						<li>Create a variable called score, set it to 98.7</li>
					</ul>
				</div>
				<textarea name="code-window" id="codeWindow" spellcheck="false" cols="80" rows="20" placeholder="Enter your code here" wrap="off"></textarea>
			</div>
		</div>
	</div>

  </body>
  <script>
	const codeInput = document.getElementById('codeWindow');
	const runButton = document.getElementById('testsButton');
	const resultsOutput = document.getElementById('resultsWindow');
	const loader = document.getElementById('loader');
	codeInput.addEventListener('keydown', function(e) {
	//allow tab indent in textarea
	if (e.key == 'Tab') {
		e.preventDefault();
		var start = this.selectionStart;
		var end = this.selectionEnd;

		// set textarea value to: text before caret + tab + text after caret
		this.value = this.value.substring(0, start) +
		  "    " + this.value.substring(end);

		// put caret at right position again
		this.selectionStart =
		  this.selectionEnd = start + 4;
		}
	});
	function formatCamelCase(camelCaseString) {
	  // 1. Insert a space before any uppercase letter.
	  // The regular expression finds a lowercase letter followed by an uppercase letter.
	  const spacedString = camelCaseString.replace(/([a-z])([A-Z])/g, '$1 $2');
	  
	  // 2. Capitalize the first letter and return the result.
	  const finalString = spacedString.charAt(0).toUpperCase() + spacedString.slice(1);
	  
	  return finalString;
	}

	/**
	 * Smoothly scrolls a container. If a target element is provided, scrolls to that element.
	 * Otherwise, scrolls to the bottom of the container.
	 * @param {HTMLElement} container The container element to scroll.
	 * @param {HTMLElement|null} targetElement The target element to scroll to.
	 * @param {number} duration The duration of the scroll in milliseconds.
	 */
	function smoothScroll(container, targetElement = null, duration = 500) {
		const startPosition = container.scrollTop;
		let endPosition;

		if (targetElement) {
			// Calculate position to scroll to the element, with a 20px offset from the top
			endPosition = targetElement.offsetTop - container.offsetTop - 20;
		} else {
			// If no target, scroll to the very bottom
			endPosition = container.scrollHeight - container.clientHeight;
		}

		const distance = endPosition - startPosition;
		let startTime = null;

		function animationStep(currentTime) {
			if (startTime === null) startTime = currentTime;
			const timeElapsed = currentTime - startTime;
			const progress = Math.min(timeElapsed / duration, 1);
			const ease = progress * (2 - progress); // easeOutQuad easing

			container.scrollTop = startPosition + distance * ease;

			if (timeElapsed < duration) {
				requestAnimationFrame(animationStep);
			}
		}

		requestAnimationFrame(animationStep);
	}

	//js to display results as a table
	function createTable(jsonString, container) {
		let data;
		try {
			data = JSON.parse(jsonString);
		} catch (error) {
			container.innerHTML = "<p>Something went wrong parsing JSON string</p>";
			return;
		}
		// Check the data is an array and not empty
		if (!Array.isArray(data) || data.length === 0) {
			container.innerHTML = "<p>No data to display.</p>";
			return;
		}
		//create table elements
		const table = document.createElement('table');
		const thead = document.createElement('thead');
		const headerRow = document.createElement('tr');
		//add table headers
		const headers = Object.keys(data[1]); //assume 0th index is summary data
		headers.forEach(hText => {
			const th = document.createElement('th');
			th.textContent = formatCamelCase(hText);
			th.classList.add(hText);
			headerRow.appendChild(th);
		});
		thead.appendChild(headerRow);
		table.appendChild(thead);

		//fill table with data
		const tbody = document.createElement('tbody');
		data.slice(1).forEach(obj => {
			const row = document.createElement('tr');
			headers.forEach(header => {
				const cell = document.createElement('td');
				cell.textContent = obj[header] !== null ? obj[header] : "";
				row.appendChild(cell);
			});
			if (obj.testResult === 'FAILED') {
				row.classList.add('test-failed');
			} else if (obj.testResult === 'SKIPPED') {
				row.classList.add('test-skipped');
			}
			row.style.animationDelay = (obj["testNumber"] / 5) + "s";
			row.classList.add("resultRow");
			tbody.appendChild(row);
		});
		table.appendChild(tbody);

		//reset container and display
		container.innerHTML = "";
		container.appendChild(table);
	}
	const clearCode = `
import sys

current_module = sys.modules[__name__]
if hasattr(current_module, '__annotations__'):
    current_module.__annotations__.clear()
	`;
	
	//testCode string
	const testCode = `
import io
import sys
import inspect
from io import StringIO
import json
from unittest.mock import patch
import random
from random import randint
from typing import get_type_hints

PASSED = 1
FAILED = -1
SKIPPED = 0

current_module = sys.modules[__name__]


#used to ignor patching random if not needed
def nevermind(*args):
    pass

class Tester:
    def __init__(self):
        self.results = []
        self.count_tests = 0
        self.count_pass = 0
        self.count_fail = 0
        
    def include_result(self, description, success):
        #success 1 = pass, 0 = skipped, -1 = failed
        result = {}
        self.count_tests += 1
        result["testNumber"] = self.count_tests
        result["testDescription"] = description
        if success == PASSED:
            self.count_pass += 1
            result["testResult"] = "PASSED"
            result["resultIcon"] = "ðŸŸ¢"
        elif success == FAILED:
            self.count_fail += 1
            result["testResult"] = "FAILED"
            result["resultIcon"] = "ðŸ”´"            
        else:
            result["testResult"] = "SKIPPED"
            result["resultIcon"] = "ðŸŸ¡"
        self.results.append(result)
        
    def confirm_variable_exists(self, v_name):
        return v_name in globals()
    
    def check_variable_exists(self, v_name):
        result = PASSED if self.confirm_variable_exists(v_name) else FAILED
        description = f"Check variable with name {v_name} exists."
        self.include_result(description ,result)
    def confirm_variable_type_hint(self,v_name,e_type):
        if self.confirm_variable_exists(v_name):
            hints = get_type_hints(current_module)
            v_value = globals()[v_name]
            if v_name not in hints:
                return False
            hint = hints[v_name]
            if hint != e_type:
                return False
            if hint != type(v_value):
                return False
            return True
        return False
    def check_variable_type_hint(self,v_name, e_type):
        if self.confirm_variable_exists(v_name):
            description = "Checking variable type hint. "
            hints = get_type_hints(current_module)
            v_value = globals()[v_name]
            #check if type hint exists
            if v_name not in hints:
                description += f"No type hint found for {v_name}."
                self.include_result(description,FAILED)
                return
            hint = hints[v_name]
            #check if type hint matches expected
            if hint == e_type:
                description += f"Type hint matches expected type. "
            else:
                description += f"Type hint doesn't match expected: {e_type}. "
                self.include_result(description, FAILED)
                return
            #check if type hint matches type of actual value
            if hint == type(v_value):
                description += f"Type hint matches actual value. "
            else:
                description += f"Type hint doesn't match type for value used, expected {e_type}, got {type(v_value)}. "
                self.include_result(description, FAILED)
                return
            self.include_result(description,PASSED)
        else:
            self.include_result(f"Unable to find variable {v_name} to check type hint.", SKIPPED)
                
            
    def check_variable_value(self,v_name,expected_value, e_type = None):
        if self.confirm_variable_exists(v_name):
            if e_type == None or self.confirm_variable_type_hint(v_name,e_type):
                description = f"Check variable {v_name} has value {expected_value}."
                actual_value = globals()[v_name]
                result = PASSED if actual_value == expected_value else FAILED
                self.include_result(description, result)
            else:
                self.include_result(f"Type hint missing or wrong for {v_name}.", SKIPPED)
        else:
            self.include_result(f"Unable to find variable {v_name} to check value.", SKIPPED)
    
    def confirm_function_exists(self,f_name):
        return f_name in globals() and callable(globals().get(f_name))
    
    def check_function_exists(self,f_name):
        result = PASSED if self.confirm_function_exists(f_name) else FAILED
        description = f"Check function with name {f_name} exists."
        self.include_result(description, result)
    
    def confirm_function_parameters(self,f_name, expected_count):
        if self.confirm_function_exists(f_name):
            signature = inspect.signature(globals()[f_name])
            actual_count = len(signature.parameters)
            return actual_count == expected_count
        return False
    
    def check_function_parameters(self,f_name,expected_count):
        if self.confirm_function_exists(f_name):
            description = f"Check function {f_name} has {expected_count} parameter(s)."
            signature = inspect.signature(globals()[f_name])
            actual_count = len(signature.parameters)
            result = PASSED if actual_count == expected_count else FAILED
            self.include_result(description,result)
        else:
            self.include_result(f"Unable to find function {f_name} to check parameters",SKIPPED)
    
    def full_check(self,f_name,args= [],inputs = [] ,randoms = [],e_out = None,e_return = None):
        if self.confirm_function_parameters(f_name,len(args)):
            #Build description
            description = f"Testing function {f_name} "
            if len(args) > 0:
                description += f"using arguments {args} "
            if len(inputs) > 0:
                description += f"with inputs {inputs} "
            description = description[:-1] + ". "
            #ignores if patching random not needed
            if len(randoms) > 0:
                #cover use of both random.randint and randint
                rand1 = "random.randint"
                rand2 = "__main__.randint"
            else:
                rand1 = "__main__.nevermind"
                rand2 = "__main__.nevermind"
            #patch inputs, print and random
            with (  patch("builtins.input", side_effect=inputs),
                    patch("sys.stdout", new=StringIO()) as fake_out,
                    patch(rand1, side_effect=randoms),
                    patch(rand2, side_effect=randoms)):
                try:
                    #run code to test
                    actual_return = globals()[f_name](*args)
                except StopIteration:
                    #gets caught if runs out of inputs or random numbers
                    result = "Failed"
                    description = f"Too many inputs or too many random numbers when testing {f_name}."
                    self.include_result(description,FAILED)
                    return
            actual_output = fake_out.getvalue().strip()
            result = PASSED
            #check for matching output
            if e_out != None and e_out != fake_out.getvalue().strip():
                description += f"Actual output does not match expected output\\nExcpected: {e_out}\\nGot: {actual_output}"
                result = FAILED
            #check for matching return
            if e_return != None and e_return != actual_return:
                description += f"Return value doesn't match.\\nExpected return: {e_return} Got: {actual_return}"
                result = FAILED
            if result == PASSED:
                description += "Test passed."
        else:
            #Doesn't run test if parameters or function name doesn't match
            result = SKIPPED
            description = f"Unable to test function {f_name}. Could not find or parameters don't match"
        self.include_result(description,result)

    def json_results(self):
        summary = {
            "testCount" : self.count_tests,
            "passCount" : self.count_pass,
            "failCount" : self.count_fail,
            "skipCount" : self.count_tests - self.count_pass - self.count_fail,
            }
        return json.dumps([summary] + self.results)

tester = Tester()
try:
    #example test code
    #full check arguments:
    #f_name : function name to test as a string
    #args : list of arguments
    #inputs : list of strings to use for input calls
    #randoms : list of ints to use for randint calls
    #e_out : expected output from print statements combined into a single string
    #e_return : expected return value from runnign function
	
	tester.check_variable_exists("username")
	tester.check_variable_type_hint("username", str)
	tester.check_variable_value("username", "Ada Lovelace", str)
	
	tester.check_variable_exists("title")
	tester.check_variable_type_hint("title", str)
	tester.check_variable_value("title", "World's first Computer Programmer", str)
	
	tester.check_variable_exists("age")
	tester.check_variable_type_hint("age", int)
	tester.check_variable_value("age", 17, int)
	
	tester.check_variable_exists("score")
	tester.check_variable_type_hint("score", float)
	tester.check_variable_value("score", 98.7, float)
	
    #tester.check_variable_exists("greeting")
    #tester.check_variable_type_hint("greeting", str)
    #tester.check_variable_value("greeting", "Hello", str)
    #tester.check_function_exists("greet")
    #tester.check_function_parameters("greet", 1)
    #tester.full_check("greet", args = ["Bob",], e_out = "Hello, Bob!")
    #tester.check_function_exists("add")
    #tester.check_function_parameters("add", 2)
    #tester.full_check("add", args = [3,4], e_return = 7)
    #tester.full_check("add", args = [-3,-2], e_return = -5)
except Exception as e:
    tester.results.append({
        "testNumber" : -1,
        "testDescription" : f"Critical error - test code could not complete: {e}",
        "testResult" : FAILED,
        "resultIcon" : "ðŸ”´" })

#final expression returned to JavaScript
tester.json_results()


#just for debugging in python

#for t in list(tester.results):
#    for k,v in t.items():
#        print(k, ":", v)
	`;

	async function setupPyodide() {
		let pyodide = await loadPyodide();
		loader.textContent = 'Python runtime loaded! Ready to run code.';
		runButton.disabled = false;
		return pyodide;
	}

	const pyodidePromise = setupPyodide();

	runButton.addEventListener('click', async () => {
		const pyodide = await pyodidePromise;
		const userCode = codeInput.value;
		resultsOutput.textContent = 'Running tests...';
		
		const initialPyodideState = pyodide.pyodide_py._state.save_state();
		let output = '';
		
		try {
			// clear stored test hints
			pyodide.runPython(clearCode);
		
			// Run the user's code to make their function available
			pyodide.runPython(userCode);
			console.log("User code completed")
			// Assign the captured string to the 'output' variable
			output = pyodide.runPython(testCode);
			console.log(output)
			createTable(output, resultsWindow);
			
			setTimeout(() => {
				const scrollContainer = document.querySelector('.left .content-wrapper');
				
				// Look for the first row with either a 'test-failed' or 'test-skipped' class.
				const firstProblemRow = scrollContainer.querySelector('.test-failed, .test-skipped');

				if (firstProblemRow) {
					// If we found a problem, scroll to it.
					smoothScroll(scrollContainer, firstProblemRow, 1000);
				} else {
					// Otherwise, all tests passed, so scroll to the bottom.
					smoothScroll(scrollContainer, null, 2000);
				}
			}, 1000);
		} catch (error) {
		
		    const errorMessage = error.toString();
        
			//look for the OSError that the console log revealed.
			if (errorMessage.includes("OSError: [Errno 29] I/O error")) {
				// This is the specific error from input(). Show the custom message.
				resultsOutput.innerHTML = `
					<p style="color: red; font-weight: bold;">Execution Halted!</p>
					<p>An <code>input()</code> call was detected in the main part of your script. Please only use <code>input()</code> inside a function definition.</p>
				`;
			} else {
				// It was a different error (e.g., a real SyntaxError)
				console.log(error); // Log the actual error for debugging
				output = "Your code would not run. Please check for errors in an IDE.";
				resultsOutput.textContent = output;
			}

		} finally {
			pyodide.pyodide_py._state.restore_state(initialPyodideState);
		}
	});
</script>
</html>
