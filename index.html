<!doctype html>
<html>
  <head>
      <script src="https://cdn.jsdelivr.net/pyodide/v0.28.3/full/pyodide.js"></script>
	  <style>
		html {
		  height: 100%;
		  font-size: 1.25rem;
		  font-family: Sans-serif;
		}
		body {
		  padding: 0;
		  margin: 0;
		  display: flex;
		  flex-direction: column;
		  height: 100%;
		}

		.nav {
		  width: 100%;
		  min-height: 50px;
		  background: navy;
		  font-family: Arial, Sans-serif;
		  color: white;
		  text-align: right;
		  padding: 10px 20px;
		  box-sizing: border-box;
		}
		.nav h1 {
		  margin: 0;
		}

		.main {
		  display: flex;
		  flex-grow:1;
		}
		.main div {
		  flex-basis: 50%;
		}
		.left {
		  background-color: lightgrey;
		  
		  justify-content: center;
		}
		.right {
		  background-color: coral;
		}

		.ðŸ’ªcenter {
		  display: flex;
		  align-items: center;
		  justify-content: center;
		  flex-direction: column;
		}
		#codeWindow {
		  font-family: monospace;
		  resize: none;
		  outline: none;
		}
		#loader {
			font-weight: bold;
			flex-grow: 0;
			flex-basis: 0;
			}
		#instructions {
			flex-basis: 0;
			flex-grow: 0;
			margin-bottom: 20px;
		}
		#resultsWindow table {
		  margin-top: 5px;
		  border: 2px solid #FFFFFF;
		  width: 100%;
		  text-align: center;
		  border-collapse: collapse;
		  overflow: hidden;
		}
		#resultsWindow table td, #resultsWindow table th {
		  border: 1px solid #FFFFFF;
		  padding: 3px 4px;
		}

		#resultsWindow table tr:nth-child(even) {
		  background: #DADADA;
		}
		#resultsWindow table thead {
			border-bottom: 4px solid #333333;
		}
		#resultsWindow table thead th {
		  font-weight: bold;
		  color: #333333;
		  text-align: center;
		}
		.resultRow {
			opacity: 0; /* Start rows as invisible */
			animation: fadeInUp 0.5s ease-out forwards;
		}
		
		@keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

	  </style>

  </head>
  <body>
	<div class="nav">
	  <h1>POCC</h1>
	</div>
	<div class="main">
	  <div class="left ðŸ’ªcenter">
		<div id="loader">Loading Python runtime... Please wait.</div>
		<button id="testsButton" disabled>Run Tests</button>
		<div id="resultsWindow"></div>
	  </div>
	  <div class="right ðŸ’ªcenter">
		<div id="instructions">
			<ul>
				<li>Create a variable called greeting with the value Hello</li>
				<li>Create a function called greet which takes in a name and says "Hello, [name]!" with the name given</li>
				<li>Create a function called add which takes two numbers and returns the sum</li>
			</ul>
		</div>
		<textarea name="code-window" id="codeWindow" spellcheck="false" cols="80" rows="20" placeholder="Enter your code here" wrap="off"></textarea>
	  </div>

	</div>
  </body>
  <script>
	const codeInput = document.getElementById('codeWindow');
	const runButton = document.getElementById('testsButton');
	const resultsOutput = document.getElementById('resultsWindow');
	const loader = document.getElementById('loader');
	codeInput.addEventListener('keydown', function(e) {
	//allow tab indent in textarea
	if (e.key == 'Tab') {
		e.preventDefault();
		var start = this.selectionStart;
		var end = this.selectionEnd;

		// set textarea value to: text before caret + tab + text after caret
		this.value = this.value.substring(0, start) +
		  "    " + this.value.substring(end);

		// put caret at right position again
		this.selectionStart =
		  this.selectionEnd = start + 4;
		}
	});
	function formatCamelCase(camelCaseString) {
	  // 1. Insert a space before any uppercase letter.
	  // The regular expression finds a lowercase letter followed by an uppercase letter.
	  const spacedString = camelCaseString.replace(/([a-z])([A-Z])/g, '$1 $2');
	  
	  // 2. Capitalize the first letter and return the result.
	  const finalString = spacedString.charAt(0).toUpperCase() + spacedString.slice(1);
	  
	  return finalString;
	}


	//js to display results as a table
	function createTable(jsonString, container) {
		let data;
		try {
			data = JSON.parse(jsonString);
		} catch (error) {
			container.innerHTML = "<p>Something went wrong parsing JSON string</p>";
			return;
		}
		// Check the data is an array and not empty
		if (!Array.isArray(data) || data.length === 0) {
			container.innerHTML = "<p>No data to display.</p>";
			return;
		}
		//create table elements
		const table = document.createElement('table');
		const thead = document.createElement('thead');
		const headerRow = document.createElement('tr');
		//add table headers
		const headers = Object.keys(data[1]); //assume 0th index is summary data
		headers.forEach(hText => {
			const th = document.createElement('th');
			th.textContent = formatCamelCase(hText);
			th.classList.add(hText);
			headerRow.appendChild(th);
		});
		thead.appendChild(headerRow);
		table.appendChild(thead);

		//fill table with data
		const tbody = document.createElement('tbody');
		data.slice(1).forEach(obj => {
			const row = document.createElement('tr');
			headers.forEach(header => {
				const cell = document.createElement('td');
				cell.textContent = obj[header] !== null ? obj[header] : "";
				row.appendChild(cell);
			});
			row.style.animationDelay = (obj["testNumber"] / 5) + "s";
			row.classList.add("resultRow");
			tbody.appendChild(row);
		});
		table.appendChild(tbody);

		//reset container and display
		container.innerHTML = "";
		container.appendChild(table);
	}
	// The new, more comprehensive testCode string
	const testCode = `
	import io
	import inspect
	from io import StringIO
	import json
	from unittest.mock import patch
	import random
	from random import randint
	
	PASSED = 1
	FAILED = -1
	SKIPPED = 0
	
	#used to ignor patching random if not needed
	def nevermind(*args):
	    pass
	
	class Tester:
	    def __init__(self):
	        self.results = []
	        self.count_tests = 0
	        self.count_pass = 0
	        self.count_fail = 0
	        
	    def include_result(self, description, success):
	        #success 1 = pass, 0 = skipped, -1 = failed
	        result = {}
	        self.count_tests += 1
	        result["testNumber"] = self.count_tests
	        result["testDescription"] = description
	        if success == PASSED:
	            self.count_pass += 1
	            result["testResult"] = "PASSED"
	            result["resultIcon"] = "ðŸŸ¢"
	        elif success == FAILED:
	            self.count_fail += 1
	            result["testResult"] = "FAILED"
	            result["resultIcon"] = "ðŸ”´"            
	        else:
	            result["testResult"] = "SKIPPED"
	            result["resultIcon"] = "ðŸŸ¡"
	        self.results.append(result)
	        
	    def confirm_variable_exists(self, v_name):
	        return v_name in globals()
	    
	    def check_variable_exists(self, v_name):
	        result = PASSED if self.confirm_variable_exists(v_name) else FAILED
	        description = f"Check variable with name {v_name} exists."
	        self.include_result(description ,result)
	    
	    def check_variable_value(self,v_name,expected_value):
	        if self.confirm_variable_exists(v_name):
	            description = f"Check variable {v_name} has value {expected_value}."
	            actual_value = globals()[v_name]
	            result = PASSED if actual_value == expected_value else FAILED
	            self.include_result(description, result)
	        else:
	            self.include_result(f"Unable to find variable {v_name} to check value", SKIPPED)
	    
	    def confirm_function_exists(self,f_name):
	        return f_name in globals() and callable(globals().get(f_name))
	    
	    def check_function_exists(self,f_name):
	        result = PASSED if self.confirm_function_exists(f_name) else FAILED
	        description = f"Check function with name {f_name} exists."
	        self.include_result(description, result)
	    
	    def confirm_function_parameters(self,f_name, expected_count):
	        if self.confirm_function_exists(f_name):
	            signature = inspect.signature(globals()[f_name])
	            actual_count = len(signature.parameters)
	            return actual_count == expected_count
	        return False
	    
	    def check_function_parameters(self,f_name,expected_count):
	        if self.confirm_function_exists(f_name):
	            description = f"Check function {f_name} has {expected_count} parameter(s)."
	            signature = inspect.signature(globals()[f_name])
	            actual_count = len(signature.parameters)
	            result = PASSED if actual_count == expected_count else FAILED
	            self.include_result(description,result)
	        else:
	            self.include_result(f"Unable to find function {f_name} to check parameters",SKIPPED)
	    
	    def full_check(self,f_name,args= [],inputs = [] ,randoms = [],e_out = None,e_return = None):
	        if self.confirm_function_parameters(f_name,len(args)):
	            #Build description
	            description = f"Testing function {f_name} "
	            if len(args) > 0:
	                description += f"using arguments {args} "
	            if len(inputs) > 0:
	                description += f"with inputs {inputs} "
	            description = description[:-1] + ". "
	            #ignores if patching random not needed
	            if len(randoms) > 0:
	                #cover use of both random.randint and randint
	                rand1 = "random.randint"
	                rand2 = "__main__.randint"
	            else:
	                rand1 = "__main__.nevermind"
	                rand2 = "__main__.nevermind"
	            #patch inputs, print and random
	            with (  patch("builtins.input", side_effect=inputs),
	                    patch("sys.stdout", new=StringIO()) as fake_out,
	                    patch(rand1, side_effect=randoms),
	                    patch(rand2, side_effect=randoms)):
	                try:
	                    #run code to test
	                    actual_return = globals()[f_name](*args)
	                except StopIteration:
	                    #gets caught if runs out of inputs or random numbers
	                    result = "Failed"
	                    description = f"Too many inputs or too many random numbers when testing {f_name}."
	                    self.include_result(description,FAILED)
	                    return
	            actual_output = fake_out.getvalue().strip()
	            result = PASSED
	            #check for matching output
	            if e_out != None and e_out != fake_out.getvalue().strip():
	                description += f"Actual output does not match expected output\nExcpected: {e_out}\nGot: {actual_output}"
	                result = FAILED
	            #check for matching return
	            if e_return != None and e_return != actual_return:
	                description += f"Return value doesn't match.\nExpected return: {e_return} Got: {actual_return}"
	                result = FAILED
	            if result == PASSED:
	                description += "Test passed."
	        else:
	            #Doesn't run test if parameters or function name doesn't match
	            result = SKIPPED
	            description = f"Unable to test function {f_name}. Could not find or parameters don't match"
	        self.include_result(description,result)
	
	    def json_results(self):
	        summary = {
	            "testCount" : self.count_tests,
	            "passCount" : self.count_pass,
	            "failCount" : self.count_fail,
	            "skipCount" : self.count_tests - self.count_pass - self.count_fail,
	            }
	        return json.dumps([summary] + self.results)
	
	tester = Tester()
	try:
	    #example test code
	    #full check arguments:
	    #f_name : function name to test as a string
	    #args : list of arguments
	    #inputs : list of strings to use for input calls
	    #randoms : list of ints to use for randint calls
	    #e_out : expected output from print statements combined into a single string
	    #e_return : expected return value from runnign function
	    tester.check_variable_exists("greeting")
	    tester.check_variable_value("greeting", "Hello")
	    tester.check_function_exists("greet")
	    tester.check_function_parameters("greet", 1)
	    tester.full_check("greet", args = ["Bob",], e_out = "Hello, Bob!")
	    tester.check_function_exists("add")
	    tester.check_function_parameters("add", 2)
	    tester.full_check("add", args = [3,4], e_return = 7)
	    tester.full_check("add", args = [5,5], e_return = 10)
	    tester.full_check("add", args = [-3,-2], e_return = -5)
	except Exception as e:
	    tester.results.append({
	        "testNumber" : -1,
	        "testDescription" : f"Critical error - test code could not complete: {e}",
	        "testResult" : FAILED,
	        "resultIcon" : "ðŸ”´" })
	
	#final expression returned to JavaScript
	tester.json_results()
	
	
	##just for debugging in python
	# for t in list(tester.results):
	#     for k,v in t.items():
	#         print(k, ":", v)
	

	`;

	async function setupPyodide() {
		let pyodide = await loadPyodide();
		loader.textContent = 'Python runtime loaded! Ready to run code.';
		runButton.disabled = false;
		return pyodide;
	}

	const pyodidePromise = setupPyodide();

	runButton.addEventListener('click', async () => {
		const pyodide = await pyodidePromise;
		const userCode = codeInput.value;
		resultsOutput.textContent = 'Running tests...';
		
		const initialPyodideState = pyodide.pyodide_py._state.save_state();
		let output = '';
		
		try {
			// Run the user's code to make their function available
			pyodide.runPython(userCode);
			console.log("User code completed")
			// Assign the captured string to the 'output' variable
			output = pyodide.runPython(testCode);
			console.log(output)
			createTable(output, resultsWindow);
		} catch (error) {
			// This will catch syntax errors in the user's code
			output = "Code would not run - please test in an IDE";
			resultsOutput.textContent = output;
		} finally {
			pyodide.pyodide_py._state.restore_state(initialPyodideState);
		}
	});
</script>
</html>
